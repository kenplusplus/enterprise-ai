diff --git a/packages/components/nodes/vectorstores/Faiss/Faiss.ts b/packages/components/nodes/vectorstores/Faiss/Faiss.ts
index 774e049e..87bc726c 100644
--- a/packages/components/nodes/vectorstores/Faiss/Faiss.ts
+++ b/packages/components/nodes/vectorstores/Faiss/Faiss.ts
@@ -109,7 +109,7 @@ class Faiss_VectorStores implements INode {
         const output = nodeData.outputs?.output as string
         const topK = nodeData.inputs?.topK as string
         const k = topK ? parseFloat(topK) : 4
-
+        console.warn(`[ZJJDBG1]Flowise->Faiss init`);
         const vectorStore = await FaissStore.load(basePath, embeddings)
 
         // Avoid illegal invocation error
@@ -136,8 +136,13 @@ const similaritySearchVectorWithScore = async (query: number[], k: number, vecto
         console.warn(`k (${k}) is greater than the number of elements in the index (${total}), setting k to ${total}`)
         k = total
     }
-
+    console.warn(`[ZJJDBG1]Faiss Searching...`);
+    const startTime = performance.now();
     const result = index.search(query, k)
+    const endTime = performance.now();
+    const searchTime = (endTime - startTime) / 1000
+    console.log(`[ZJJDBG]Faiss Search execution time: ${searchTime.toFixed(3)} seconds`);
+
     return result.labels.map((id, index) => {
         const uuid = vectorStore._mapping[id]
         return [vectorStore.docstore.search(uuid), result.distances[index]] as [Document, number]
diff --git a/packages/components/nodes/vectorstores/Faiss/Faiss_Existing.ts b/packages/components/nodes/vectorstores/Faiss/Faiss_Existing.ts
index b5cd5dba..b6cb9438 100644
--- a/packages/components/nodes/vectorstores/Faiss/Faiss_Existing.ts
+++ b/packages/components/nodes/vectorstores/Faiss/Faiss_Existing.ts
@@ -82,7 +82,7 @@ class Faiss_Existing_VectorStores implements INode {
                 console.warn(`k (${k}) is greater than the number of elements in the index (${total}), setting k to ${total}`)
                 k = total
             }
-
+            console.warn(`[ZJJDBG1]Faiss_Existing search...`);
             const result = index.search(query, k)
             return result.labels.map((id, index) => {
                 const uuid = vectorStore._mapping[id]
diff --git a/packages/components/nodes/vectorstores/xFaiss/Faiss.ts b/packages/components/nodes/vectorstores/xFaiss/Faiss.ts
new file mode 100644
index 00000000..fe238ccf
--- /dev/null
+++ b/packages/components/nodes/vectorstores/xFaiss/Faiss.ts
@@ -0,0 +1,157 @@
+import { flatten } from 'lodash'
+import { Document } from '@langchain/core/documents'
+import { FaissStore } from './langchain/xfaiss'
+import { Embeddings } from '@langchain/core/embeddings'
+import { INode, INodeData, INodeOutputsValue, INodeParams, IndexingResult } from '../../../src/Interface'
+import { getBaseClasses } from '../../../src/utils'
+
+class Faiss_VectorStores implements INode {
+    label: string
+    name: string
+    version: number
+    description: string
+    type: string
+    icon: string
+    category: string
+    badge: string
+    baseClasses: string[]
+    inputs: INodeParams[]
+    outputs: INodeOutputsValue[]
+
+    constructor() {
+        this.label = 'xFaiss'
+        this.name = 'xfaiss'
+        this.version = 1.0
+        this.type = 'xFaiss'
+        this.icon = 'faiss.svg'
+        this.category = 'Vector Stores'
+        this.description = 'Upsert embedded data and perform similarity search upon query using Faiss library from Meta'
+        this.baseClasses = [this.type, 'VectorStoreRetriever', 'BaseRetriever']
+        this.badge = 'NEW'
+        this.inputs = [
+            {
+                label: 'Document',
+                name: 'document',
+                type: 'Document',
+                list: true,
+                optional: true
+            },
+            {
+                label: 'Embeddings',
+                name: 'embeddings',
+                type: 'Embeddings'
+            },
+            {
+                label: 'Base Path to load',
+                name: 'basePath',
+                description: 'Path to load faiss.index file',
+                placeholder: `C:\\Users\\User\\Desktop`,
+                type: 'string'
+            },
+            {
+                label: 'Top K',
+                name: 'topK',
+                description: 'Number of top results to fetch. Default to 4',
+                placeholder: '4',
+                type: 'number',
+                additionalParams: true,
+                optional: true
+            }
+        ]
+        this.outputs = [
+            {
+                label: 'Faiss Retriever',
+                name: 'retriever',
+                baseClasses: this.baseClasses
+            },
+            {
+                label: 'Faiss Vector Store',
+                name: 'vectorStore',
+                baseClasses: [this.type, ...getBaseClasses(FaissStore)]
+            }
+        ]
+    }
+
+    //@ts-ignore
+    vectorStoreMethods = {
+        async upsert(nodeData: INodeData): Promise<Partial<IndexingResult>> {
+            const docs = nodeData.inputs?.document as Document[]
+            const embeddings = nodeData.inputs?.embeddings as Embeddings
+            const basePath = nodeData.inputs?.basePath as string
+
+            const flattenDocs = docs && docs.length ? flatten(docs) : []
+            const finalDocs = []
+            for (let i = 0; i < flattenDocs.length; i += 1) {
+                if (flattenDocs[i] && flattenDocs[i].pageContent) {
+                    finalDocs.push(new Document(flattenDocs[i]))
+                }
+            }
+
+            try {
+                console.warn(`[ZJJDBG]indexing0 (pdf -> faiss -> embedding) saving...`);
+                const startTime = performance.now();
+                const vectorStore = await FaissStore.fromDocuments(finalDocs, embeddings)
+                await vectorStore.save(basePath)
+                const endTime = performance.now();
+                const searchTime = (endTime - startTime) / 1000
+                console.log(`[ZJJDBG]indexing0 execution time: ${searchTime.toFixed(3)} seconds`);
+
+                // Avoid illegal invocation error
+                vectorStore.similaritySearchVectorWithScore = async (query: number[], k: number) => {
+                    return await similaritySearchVectorWithScore(query, k, vectorStore)
+                }
+
+                return { numAdded: finalDocs.length, addedDocs: finalDocs }
+            } catch (e) {
+                throw new Error(e)
+            }
+        }
+    }
+
+    async init(nodeData: INodeData): Promise<any> {
+        const embeddings = nodeData.inputs?.embeddings as Embeddings
+        const basePath = nodeData.inputs?.basePath as string
+        const output = nodeData.outputs?.output as string
+        const topK = nodeData.inputs?.topK as string
+        const k = topK ? parseFloat(topK) : 4
+        console.warn(`[ZJJDBG1]Flowise->xFaiss init`);
+        const vectorStore = await FaissStore.load(basePath, embeddings)
+
+        // Avoid illegal invocation error
+        vectorStore.similaritySearchVectorWithScore = async (query: number[], k: number) => {
+            return await similaritySearchVectorWithScore(query, k, vectorStore)
+        }
+
+        if (output === 'retriever') {
+            const retriever = vectorStore.asRetriever(k)
+            return retriever
+        } else if (output === 'vectorStore') {
+            ;(vectorStore as any).k = k
+            return vectorStore
+        }
+        return vectorStore
+    }
+}
+
+const similaritySearchVectorWithScore = async (query: number[], k: number, vectorStore: FaissStore) => {
+    const index = vectorStore.index
+
+    if (k > index.ntotal()) {
+        const total = index.ntotal()
+        console.warn(`k (${k}) is greater than the number of elements in the index (${total}), setting k to ${total}`)
+        k = total
+    }
+    console.warn(`[ZJJDBG1]xFaiss Searching...`);
+    const startTime = performance.now();
+    const result = index.search(query, k)
+    const endTime = performance.now();
+    const searchTime = (endTime - startTime) / 1000
+    console.log(`[ZJJDBG]xFaiss Search execution time: ${searchTime.toFixed(3)} seconds`);
+
+    return result.labels.map((id, index) => {
+        const uuid = vectorStore._mapping[id]
+        return [vectorStore.docstore.search(uuid), result.distances[index]] as [Document, number]
+    })
+}
+
+module.exports = { nodeClass: Faiss_VectorStores }
diff --git a/packages/components/nodes/vectorstores/xFaiss/Faiss_Existing.ts b/packages/components/nodes/vectorstores/xFaiss/Faiss_Existing.ts
new file mode 100644
index 00000000..55e8ccc6
--- /dev/null
+++ b/packages/components/nodes/vectorstores/xFaiss/Faiss_Existing.ts
@@ -0,0 +1,103 @@
+import { FaissStore } from './langchain/xfaiss'
+import { Embeddings } from '@langchain/core/embeddings'
+import { Document } from '@langchain/core/documents'
+import { INode, INodeData, INodeOutputsValue, INodeParams } from '../../../src/Interface'
+import { getBaseClasses } from '../../../src/utils'
+
+class Faiss_Existing_VectorStores implements INode {
+    label: string
+    name: string
+    version: number
+    description: string
+    type: string
+    icon: string
+    category: string
+    badge: string
+    baseClasses: string[]
+    inputs: INodeParams[]
+    outputs: INodeOutputsValue[]
+
+    constructor() {
+        this.label = 'xFaiss Load Existing Index'
+        this.name = 'xfaissExistingIndex'
+        this.version = 1.0
+        this.type = 'xFaiss'
+        this.icon = 'faiss.svg'
+        this.category = 'Vector Stores'
+        this.description = 'Load existing index from Faiss (i.e: Document has been upserted)'
+        this.baseClasses = [this.type, 'VectorStoreRetriever', 'BaseRetriever']
+        this.badge = 'DEPRECATING'
+        this.inputs = [
+            {
+                label: 'Embeddings',
+                name: 'embeddings',
+                type: 'Embeddings'
+            },
+            {
+                label: 'Base Path to load',
+                name: 'basePath',
+                description: 'Path to load faiss.index file',
+                placeholder: `C:\\Users\\User\\Desktop`,
+                type: 'string'
+            },
+            {
+                label: 'Top K',
+                name: 'topK',
+                description: 'Number of top results to fetch. Default to 4',
+                placeholder: '4',
+                type: 'number',
+                additionalParams: true,
+                optional: true
+            }
+        ]
+        this.outputs = [
+            {
+                label: 'Faiss Retriever',
+                name: 'retriever',
+                baseClasses: this.baseClasses
+            },
+            {
+                label: 'Faiss Vector Store',
+                name: 'vectorStore',
+                baseClasses: [this.type, ...getBaseClasses(FaissStore)]
+            }
+        ]
+    }
+
+    async init(nodeData: INodeData): Promise<any> {
+        const embeddings = nodeData.inputs?.embeddings as Embeddings
+        const basePath = nodeData.inputs?.basePath as string
+        const output = nodeData.outputs?.output as string
+        const topK = nodeData.inputs?.topK as string
+        const k = topK ? parseFloat(topK) : 4
+        const vectorStore = await FaissStore.load(basePath, embeddings)
+
+        // Avoid illegal invocation error
+        vectorStore.similaritySearchVectorWithScore = async (query: number[], k: number) => {
+            const index = vectorStore.index
+            console.warn(`[ZJJDBG1]Flowise->xFaiss_Existing search`);
+            if (k > index.ntotal()) {
+                const total = index.ntotal()
+                console.warn(`k (${k}) is greater than the number of elements in the index (${total}), setting k to ${total}`)
+                k = total
+            }
+
+            const result = index.search(query, k)
+            return result.labels.map((id, index) => {
+                const uuid = vectorStore._mapping[id]
+                return [vectorStore.docstore.search(uuid), result.distances[index]] as [Document, number]
+            })
+        }
+
+        if (output === 'retriever') {
+            const retriever = vectorStore.asRetriever(k)
+            return retriever
+        } else if (output === 'vectorStore') {
+            ;(vectorStore as any).k = k
+            return vectorStore
+        }
+        return vectorStore
+    }
+}
+
+module.exports = { nodeClass: Faiss_Existing_VectorStores }
diff --git a/packages/components/nodes/vectorstores/xFaiss/Faiss_Upsert.ts b/packages/components/nodes/vectorstores/xFaiss/Faiss_Upsert.ts
new file mode 100644
index 00000000..bbddbc72
--- /dev/null
+++ b/packages/components/nodes/vectorstores/xFaiss/Faiss_Upsert.ts
@@ -0,0 +1,125 @@
+import { flatten } from 'lodash'
+import { Embeddings } from '@langchain/core/embeddings'
+import { Document } from '@langchain/core/documents'
+import { FaissStore } from './langchain/xfaiss'
+import { INode, INodeData, INodeOutputsValue, INodeParams } from '../../../src/Interface'
+import { getBaseClasses } from '../../../src/utils'
+
+class FaissUpsert_VectorStores implements INode {
+    label: string
+    name: string
+    version: number
+    description: string
+    type: string
+    icon: string
+    category: string
+    badge: string
+    baseClasses: string[]
+    inputs: INodeParams[]
+    outputs: INodeOutputsValue[]
+
+    constructor() {
+        this.label = 'xFaiss Upsert Document'
+        this.name = 'xfaissUpsert'
+        this.version = 1.0
+        this.type = 'xFaiss'
+        this.icon = 'faiss.svg'
+        this.category = 'Vector Stores'
+        this.description = 'Upsert documents to Faiss'
+        this.baseClasses = [this.type, 'VectorStoreRetriever', 'BaseRetriever']
+        this.badge = 'DEPRECATING'
+        this.inputs = [
+            {
+                label: 'Document',
+                name: 'document',
+                type: 'Document',
+                list: true
+            },
+            {
+                label: 'Embeddings',
+                name: 'embeddings',
+                type: 'Embeddings'
+            },
+            {
+                label: 'Base Path to store',
+                name: 'basePath',
+                description: 'Path to store faiss.index file',
+                placeholder: `C:\\Users\\User\\Desktop`,
+                type: 'string'
+            },
+            {
+                label: 'Top K',
+                name: 'topK',
+                description: 'Number of top results to fetch. Default to 4',
+                placeholder: '4',
+                type: 'number',
+                additionalParams: true,
+                optional: true
+            }
+        ]
+        this.outputs = [
+            {
+                label: 'Faiss Retriever',
+                name: 'retriever',
+                baseClasses: this.baseClasses
+            },
+            {
+                label: 'Faiss Vector Store',
+                name: 'vectorStore',
+                baseClasses: [this.type, ...getBaseClasses(FaissStore)]
+            }
+        ]
+    }
+
+    async init(nodeData: INodeData): Promise<any> {
+        const docs = nodeData.inputs?.document as Document[]
+        const embeddings = nodeData.inputs?.embeddings as Embeddings
+        const output = nodeData.outputs?.output as string
+        const basePath = nodeData.inputs?.basePath as string
+        const topK = nodeData.inputs?.topK as string
+        const k = topK ? parseFloat(topK) : 4
+
+        const flattenDocs = docs && docs.length ? flatten(docs) : []
+        const finalDocs = []
+        for (let i = 0; i < flattenDocs.length; i += 1) {
+            if (flattenDocs[i] && flattenDocs[i].pageContent) {
+                finalDocs.push(new Document(flattenDocs[i]))
+            }
+        }
+        console.warn(`[ZJJDBG]indexing1 (pdf -> faiss -> embedding) saving...`);
+        const startTime = performance.now();
+        const vectorStore = await FaissStore.fromDocuments(finalDocs, embeddings)
+        await vectorStore.save(basePath)
+        const endTime = performance.now();
+        const searchTime = (endTime - startTime) / 1000
+        console.log(`[ZJJDBG]indexing1 execution time: ${searchTime.toFixed(3)} seconds`);
+
+        // Avoid illegal invocation error
+        vectorStore.similaritySearchVectorWithScore = async (query: number[], k: number) => {
+            const index = vectorStore.index
+
+            if (k > index.ntotal()) {
+                const total = index.ntotal()
+                console.warn(`k (${k}) is greater than the number of elements in the index (${total}), setting k to ${total}`)
+                k = total
+            }
+
+            const result = index.search(query, k)
+            return result.labels.map((id, index) => {
+                const uuid = vectorStore._mapping[id]
+                return [vectorStore.docstore.search(uuid), result.distances[index]] as [Document, number]
+            })
+        }
+
+        if (output === 'retriever') {
+            const retriever = vectorStore.asRetriever(k)
+            return retriever
+        } else if (output === 'vectorStore') {
+            ;(vectorStore as any).k = k
+            return vectorStore
+        }
+        return vectorStore
+    }
+}
+
+module.exports = { nodeClass: FaissUpsert_VectorStores }
diff --git a/packages/components/nodes/vectorstores/xFaiss/faiss.svg b/packages/components/nodes/vectorstores/xFaiss/faiss.svg
new file mode 100644
index 00000000..d56ad86b
--- /dev/null
+++ b/packages/components/nodes/vectorstores/xFaiss/faiss.svg
@@ -0,0 +1,9 @@
+<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
+<path d="M5 10C5 10.7956 5.31607 11.5587 5.87868 12.1213C6.44129 12.6839 7.20435 13 8 13C8.79565 13 9.55871 12.6839 10.1213 12.1213C10.6839 11.5587 11 10.7956 11 10C11 9.20435 10.6839 8.44129 10.1213 7.87868C9.55871 7.31607 8.79565 7 8 7C7.20435 7 6.44129 7.31607 5.87868 7.87868C5.31607 8.44129 5 9.20435 5 10Z" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
+<path d="M20 19.5C20 20.163 20.2634 20.7989 20.7322 21.2678C21.2011 21.7366 21.837 22 22.5 22C23.163 22 23.7989 21.7366 24.2678 21.2678C24.7366 20.7989 25 20.163 25 19.5C25 18.837 24.7366 18.2011 24.2678 17.7322C23.7989 17.2634 23.163 17 22.5 17C21.837 17 21.2011 17.2634 20.7322 17.7322C20.2634 18.2011 20 18.837 20 19.5Z" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
+<path d="M19 8.5C19 9.42826 19.3687 10.3185 20.0251 10.9749C20.6815 11.6313 21.5717 12 22.5 12C23.4283 12 24.3185 11.6313 24.9749 10.9749C25.6313 10.3185 26 9.42826 26 8.5C26 7.57174 25.6313 6.6815 24.9749 6.02513C24.3185 5.36875 23.4283 5 22.5 5C21.5717 5 20.6815 5.36875 20.0251 6.02513C19.3687 6.6815 19 7.57174 19 8.5Z" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
+<path d="M5 23C5 24.0609 5.42143 25.0783 6.17157 25.8284C6.92172 26.5786 7.93913 27 9 27C10.0609 27 11.0783 26.5786 11.8284 25.8284C12.5786 25.0783 13 24.0609 13 23C13 21.9391 12.5786 20.9217 11.8284 20.1716C11.0783 19.4214 10.0609 19 9 19C7.93913 19 6.92172 19.4214 6.17157 20.1716C5.42143 20.9217 5 21.9391 5 23Z" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
+<path d="M13 22L20 20" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
+<path d="M10.5 12L20 18" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
+<path d="M11 9.5L18.5 8.5" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
+</svg>
diff --git a/packages/components/nodes/vectorstores/xFaiss/langchain/doc/base.cjs b/packages/components/nodes/vectorstores/xFaiss/langchain/doc/base.cjs
new file mode 100644
index 00000000..1dff9e53
--- /dev/null
+++ b/packages/components/nodes/vectorstores/xFaiss/langchain/doc/base.cjs
@@ -0,0 +1,10 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.Docstore = void 0;
+/**
+ * Abstract class for a document store. All document stores should extend
+ * this class.
+ */
+class Docstore {
+}
+exports.Docstore = Docstore;
diff --git a/packages/components/nodes/vectorstores/xFaiss/langchain/doc/base.d.ts b/packages/components/nodes/vectorstores/xFaiss/langchain/doc/base.d.ts
new file mode 100644
index 00000000..5afbc63b
--- /dev/null
+++ b/packages/components/nodes/vectorstores/xFaiss/langchain/doc/base.d.ts
@@ -0,0 +1,9 @@
+import { Document } from "@langchain/core/documents";
+/**
+ * Abstract class for a document store. All document stores should extend
+ * this class.
+ */
+export declare abstract class Docstore {
+    abstract search(search: string): Promise<Document>;
+    abstract add(texts: Record<string, Document>): Promise<void>;
+}
diff --git a/packages/components/nodes/vectorstores/xFaiss/langchain/doc/base.js b/packages/components/nodes/vectorstores/xFaiss/langchain/doc/base.js
new file mode 100644
index 00000000..357a19fb
--- /dev/null
+++ b/packages/components/nodes/vectorstores/xFaiss/langchain/doc/base.js
@@ -0,0 +1,6 @@
+/**
+ * Abstract class for a document store. All document stores should extend
+ * this class.
+ */
+export class Docstore {
+}
diff --git a/packages/components/nodes/vectorstores/xFaiss/langchain/doc/in_memory.cjs b/packages/components/nodes/vectorstores/xFaiss/langchain/doc/in_memory.cjs
new file mode 100644
index 00000000..2f1dc781
--- /dev/null
+++ b/packages/components/nodes/vectorstores/xFaiss/langchain/doc/in_memory.cjs
@@ -0,0 +1,107 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.SynchronousInMemoryDocstore = exports.InMemoryDocstore = void 0;
+const base_js_1 = require("./base.cjs");
+/**
+ * Class for storing and retrieving documents in memory asynchronously.
+ * Extends the Docstore class.
+ */
+class InMemoryDocstore extends base_js_1.Docstore {
+    constructor(docs) {
+        super();
+        Object.defineProperty(this, "_docs", {
+            enumerable: true,
+            configurable: true,
+            writable: true,
+            value: void 0
+        });
+        this._docs = docs ?? new Map();
+    }
+    /**
+     * Searches for a document in the store based on its ID.
+     * @param search The ID of the document to search for.
+     * @returns The document with the given ID.
+     */
+    async search(search) {
+        const result = this._docs.get(search);
+        if (!result) {
+            throw new Error(`ID ${search} not found.`);
+        }
+        else {
+            return result;
+        }
+    }
+    /**
+     * Adds new documents to the store.
+     * @param texts An object where the keys are document IDs and the values are the documents themselves.
+     * @returns Void
+     */
+    async add(texts) {
+        const keys = [...this._docs.keys()];
+        const overlapping = Object.keys(texts).filter((x) => keys.includes(x));
+        if (overlapping.length > 0) {
+            throw new Error(`Tried to add ids that already exist: ${overlapping}`);
+        }
+        for (const [key, value] of Object.entries(texts)) {
+            this._docs.set(key, value);
+        }
+    }
+    async mget(keys) {
+        return Promise.all(keys.map((key) => this.search(key)));
+    }
+    async mset(keyValuePairs) {
+        await Promise.all(keyValuePairs.map(([key, value]) => this.add({ [key]: value })));
+    }
+    async mdelete(_keys) {
+        throw new Error("Not implemented.");
+    }
+    // eslint-disable-next-line require-yield
+    async *yieldKeys(_prefix) {
+        throw new Error("Not implemented");
+    }
+}
+exports.InMemoryDocstore = InMemoryDocstore;
+/**
+ * Class for storing and retrieving documents in memory synchronously.
+ */
+class SynchronousInMemoryDocstore {
+    constructor(docs) {
+        Object.defineProperty(this, "_docs", {
+            enumerable: true,
+            configurable: true,
+            writable: true,
+            value: void 0
+        });
+        this._docs = docs ?? new Map();
+    }
+    /**
+     * Searches for a document in the store based on its ID.
+     * @param search The ID of the document to search for.
+     * @returns The document with the given ID.
+     */
+    search(search) {
+        const result = this._docs.get(search);
+        if (!result) {
+            throw new Error(`ID ${search} not found.`);
+        }
+        else {
+            return result;
+        }
+    }
+    /**
+     * Adds new documents to the store.
+     * @param texts An object where the keys are document IDs and the values are the documents themselves.
+     * @returns Void
+     */
+    add(texts) {
+        const keys = [...this._docs.keys()];
+        const overlapping = Object.keys(texts).filter((x) => keys.includes(x));
+        if (overlapping.length > 0) {
+            throw new Error(`Tried to add ids that already exist: ${overlapping}`);
+        }
+        for (const [key, value] of Object.entries(texts)) {
+            this._docs.set(key, value);
+        }
+    }
+}
+exports.SynchronousInMemoryDocstore = SynchronousInMemoryDocstore;
diff --git a/packages/components/nodes/vectorstores/xFaiss/langchain/doc/in_memory.d.ts b/packages/components/nodes/vectorstores/xFaiss/langchain/doc/in_memory.d.ts
new file mode 100644
index 00000000..6f040a39
--- /dev/null
+++ b/packages/components/nodes/vectorstores/xFaiss/langchain/doc/in_memory.d.ts
@@ -0,0 +1,46 @@
+import { Document } from "@langchain/core/documents";
+import { BaseStoreInterface } from "@langchain/core/stores";
+import { Docstore } from "./base.js";
+/**
+ * Class for storing and retrieving documents in memory asynchronously.
+ * Extends the Docstore class.
+ */
+export declare class InMemoryDocstore extends Docstore implements BaseStoreInterface<string, Document> {
+    _docs: Map<string, Document>;
+    constructor(docs?: Map<string, Document>);
+    /**
+     * Searches for a document in the store based on its ID.
+     * @param search The ID of the document to search for.
+     * @returns The document with the given ID.
+     */
+    search(search: string): Promise<Document>;
+    /**
+     * Adds new documents to the store.
+     * @param texts An object where the keys are document IDs and the values are the documents themselves.
+     * @returns Void
+     */
+    add(texts: Record<string, Document>): Promise<void>;
+    mget(keys: string[]): Promise<Document[]>;
+    mset(keyValuePairs: [string, Document][]): Promise<void>;
+    mdelete(_keys: string[]): Promise<void>;
+    yieldKeys(_prefix?: string): AsyncGenerator<string>;
+}
+/**
+ * Class for storing and retrieving documents in memory synchronously.
+ */
+export declare class SynchronousInMemoryDocstore {
+    _docs: Map<string, Document>;
+    constructor(docs?: Map<string, Document>);
+    /**
+     * Searches for a document in the store based on its ID.
+     * @param search The ID of the document to search for.
+     * @returns The document with the given ID.
+     */
+    search(search: string): Document;
+    /**
+     * Adds new documents to the store.
+     * @param texts An object where the keys are document IDs and the values are the documents themselves.
+     * @returns Void
+     */
+    add(texts: Record<string, Document>): void;
+}
diff --git a/packages/components/nodes/vectorstores/xFaiss/langchain/doc/in_memory.js b/packages/components/nodes/vectorstores/xFaiss/langchain/doc/in_memory.js
new file mode 100644
index 00000000..1cef551e
--- /dev/null
+++ b/packages/components/nodes/vectorstores/xFaiss/langchain/doc/in_memory.js
@@ -0,0 +1,102 @@
+import { Docstore } from "./base.js";
+/**
+ * Class for storing and retrieving documents in memory asynchronously.
+ * Extends the Docstore class.
+ */
+export class InMemoryDocstore extends Docstore {
+    constructor(docs) {
+        super();
+        Object.defineProperty(this, "_docs", {
+            enumerable: true,
+            configurable: true,
+            writable: true,
+            value: void 0
+        });
+        this._docs = docs ?? new Map();
+    }
+    /**
+     * Searches for a document in the store based on its ID.
+     * @param search The ID of the document to search for.
+     * @returns The document with the given ID.
+     */
+    async search(search) {
+        const result = this._docs.get(search);
+        if (!result) {
+            throw new Error(`ID ${search} not found.`);
+        }
+        else {
+            return result;
+        }
+    }
+    /**
+     * Adds new documents to the store.
+     * @param texts An object where the keys are document IDs and the values are the documents themselves.
+     * @returns Void
+     */
+    async add(texts) {
+        const keys = [...this._docs.keys()];
+        const overlapping = Object.keys(texts).filter((x) => keys.includes(x));
+        if (overlapping.length > 0) {
+            throw new Error(`Tried to add ids that already exist: ${overlapping}`);
+        }
+        for (const [key, value] of Object.entries(texts)) {
+            this._docs.set(key, value);
+        }
+    }
+    async mget(keys) {
+        return Promise.all(keys.map((key) => this.search(key)));
+    }
+    async mset(keyValuePairs) {
+        await Promise.all(keyValuePairs.map(([key, value]) => this.add({ [key]: value })));
+    }
+    async mdelete(_keys) {
+        throw new Error("Not implemented.");
+    }
+    // eslint-disable-next-line require-yield
+    async *yieldKeys(_prefix) {
+        throw new Error("Not implemented");
+    }
+}
+/**
+ * Class for storing and retrieving documents in memory synchronously.
+ */
+export class SynchronousInMemoryDocstore {
+    constructor(docs) {
+        Object.defineProperty(this, "_docs", {
+            enumerable: true,
+            configurable: true,
+            writable: true,
+            value: void 0
+        });
+        this._docs = docs ?? new Map();
+    }
+    /**
+     * Searches for a document in the store based on its ID.
+     * @param search The ID of the document to search for.
+     * @returns The document with the given ID.
+     */
+    search(search) {
+        const result = this._docs.get(search);
+        if (!result) {
+            throw new Error(`ID ${search} not found.`);
+        }
+        else {
+            return result;
+        }
+    }
+    /**
+     * Adds new documents to the store.
+     * @param texts An object where the keys are document IDs and the values are the documents themselves.
+     * @returns Void
+     */
+    add(texts) {
+        const keys = [...this._docs.keys()];
+        const overlapping = Object.keys(texts).filter((x) => keys.includes(x));
+        if (overlapping.length > 0) {
+            throw new Error(`Tried to add ids that already exist: ${overlapping}`);
+        }
+        for (const [key, value] of Object.entries(texts)) {
+            this._docs.set(key, value);
+        }
+    }
+}
diff --git a/packages/components/nodes/vectorstores/xFaiss/langchain/xfaiss.cjs b/packages/components/nodes/vectorstores/xFaiss/langchain/xfaiss.cjs
new file mode 100644
index 00000000..fb05eb05
--- /dev/null
+++ b/packages/components/nodes/vectorstores/xFaiss/langchain/xfaiss.cjs
@@ -0,0 +1,397 @@
+"use strict";
+var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    var desc = Object.getOwnPropertyDescriptor(m, k);
+    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
+      desc = { enumerable: true, get: function() { return m[k]; } };
+    }
+    Object.defineProperty(o, k2, desc);
+}) : (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    o[k2] = m[k];
+}));
+var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
+    Object.defineProperty(o, "default", { enumerable: true, value: v });
+}) : function(o, v) {
+    o["default"] = v;
+});
+var __importStar = (this && this.__importStar) || function (mod) {
+    if (mod && mod.__esModule) return mod;
+    var result = {};
+    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
+    __setModuleDefault(result, mod);
+    return result;
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.FaissStore = void 0;
+const uuid = __importStar(require("uuid"));
+const vectorstores_1 = require("@langchain/core/vectorstores");
+const documents_1 = require("@langchain/core/documents");
+const in_memory_js_1 = require("./doc/in_memory.cjs");
+/**
+ * A class that wraps the FAISS (Facebook AI Similarity Search) vector
+ * database for efficient similarity search and clustering of dense
+ * vectors.
+ */
+class FaissStore extends vectorstores_1.SaveableVectorStore {
+    _vectorstoreType() {
+        return "faiss";
+    }
+    getMapping() {
+        return this._mapping;
+    }
+    getDocstore() {
+        return this.docstore;
+    }
+    constructor(embeddings, args) {
+        super(embeddings, args);
+        Object.defineProperty(this, "_index", {
+            enumerable: true,
+            configurable: true,
+            writable: true,
+            value: void 0
+        });
+        Object.defineProperty(this, "_mapping", {
+            enumerable: true,
+            configurable: true,
+            writable: true,
+            value: void 0
+        });
+        Object.defineProperty(this, "docstore", {
+            enumerable: true,
+            configurable: true,
+            writable: true,
+            value: void 0
+        });
+        Object.defineProperty(this, "args", {
+            enumerable: true,
+            configurable: true,
+            writable: true,
+            value: void 0
+        });
+        this.args = args;
+        this._index = args.index;
+        this._mapping = args.mapping ?? {};
+        this.embeddings = embeddings;
+        this.docstore = args?.docstore ?? new in_memory_js_1.SynchronousInMemoryDocstore();
+    }
+    /**
+     * Adds an array of Document objects to the store.
+     * @param documents An array of Document objects.
+     * @returns A Promise that resolves when the documents have been added.
+     */
+    async addDocuments(documents, options) {
+        const texts = documents.map(({ pageContent }) => pageContent);
+        return this.addVectors(await this.embeddings.embedDocuments(texts), documents, options);
+    }
+    get index() {
+        if (!this._index) {
+            throw new Error("Vector store not initialised yet. Try calling `fromTexts`, `fromDocuments` or `fromIndex` first.");
+        }
+        return this._index;
+    }
+    set index(index) {
+        this._index = index;
+    }
+    /**
+     * Adds an array of vectors and their corresponding Document objects to
+     * the store.
+     * @param vectors An array of vectors.
+     * @param documents An array of Document objects corresponding to the vectors.
+     * @returns A Promise that resolves with an array of document IDs when the vectors and documents have been added.
+     */
+    async addVectors(vectors, documents, options) {
+        if (vectors.length === 0) {
+            return [];
+        }
+        if (vectors.length !== documents.length) {
+            throw new Error(`Vectors and documents must have the same length`);
+        }
+        const dv = vectors[0].length;
+        if (!this._index) {
+            const { IndexFlatIP } = await FaissStore.importFaiss();
+            this._index = new IndexFlatIP(dv);
+        }
+        const d = this.index.getDimension();
+        if (dv !== d) {
+            throw new Error(`Vectors must have the same length as the number of dimensions (${d})`);
+        }
+        const docstoreSize = this.index.ntotal();
+        const documentIds = options?.ids ?? documents.map(() => uuid.v4());
+        for (let i = 0; i < vectors.length; i += 1) {
+            const documentId = documentIds[i];
+            const id = docstoreSize + i;
+            this.index.add(vectors[i]);
+            this._mapping[id] = documentId;
+            this.docstore.add({ [documentId]: documents[i] });
+        }
+        return documentIds;
+    }
+    /**
+     * Performs a similarity search in the vector store using a query vector
+     * and returns the top k results along with their scores.
+     * @param query A query vector.
+     * @param k The number of top results to return.
+     * @returns A Promise that resolves with an array of tuples, each containing a Document and its corresponding score.
+     */
+    async similaritySearchVectorWithScore(query, k) {
+        const d = this.index.getDimension();
+        if (query.length !== d) {
+            throw new Error(`Query vector must have the same length as the number of dimensions (${d})`);
+        }
+        if (k > this.index.ntotal()) {
+            const total = this.index.ntotal();
+            console.warn(`k (${k}) is greater than the number of elements in the index (${total}), setting k to ${total}`);
+            // eslint-disable-next-line no-param-reassign
+            k = total;
+        }
+        const result = this.index.search(query, k);
+        return result.labels.map((id, index) => {
+            const uuid = this._mapping[id];
+            return [this.docstore.search(uuid), result.distances[index]];
+        });
+    }
+    /**
+     * Saves the current state of the FaissStore to a specified directory.
+     * @param directory The directory to save the state to.
+     * @returns A Promise that resolves when the state has been saved.
+     */
+    async save(directory) {
+        const fs = await import("node:fs/promises");
+        const path = await import("node:path");
+        await fs.mkdir(directory, { recursive: true });
+        await Promise.all([
+            this.index.write(path.join(directory, "faiss.index")),
+            await fs.writeFile(path.join(directory, "docstore.json"), JSON.stringify([
+                Array.from(this.docstore._docs.entries()),
+                this._mapping,
+            ])),
+        ]);
+    }
+    /**
+     * Method to delete documents.
+     * @param params Object containing the IDs of the documents to delete.
+     * @returns A promise that resolves when the deletion is complete.
+     */
+    async delete(params) {
+        const documentIds = params.ids;
+        if (documentIds == null) {
+            throw new Error("No documentIds provided to delete.");
+        }
+        const mappings = new Map(Object.entries(this._mapping).map(([key, value]) => [
+            parseInt(key, 10),
+            value,
+        ]));
+        const reversedMappings = new Map(Array.from(mappings, (entry) => [entry[1], entry[0]]));
+        const missingIds = new Set(documentIds.filter((id) => !reversedMappings.has(id)));
+        if (missingIds.size > 0) {
+            throw new Error(`Some specified documentIds do not exist in the current store. DocumentIds not found: ${Array.from(missingIds).join(", ")}`);
+        }
+        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
+        const indexIdToDelete = documentIds.map((id) => reversedMappings.get(id));
+        // remove from index
+        this.index.removeIds(indexIdToDelete);
+        // remove from docstore
+        documentIds.forEach((id) => {
+            this.docstore._docs.delete(id);
+        });
+        // remove from mappings
+        indexIdToDelete.forEach((id) => {
+            mappings.delete(id);
+        });
+        this._mapping = { ...Array.from(mappings.values()) };
+    }
+    /**
+     * Merges the current FaissStore with another FaissStore.
+     * @param targetIndex The FaissStore to merge with.
+     * @returns A Promise that resolves with an array of document IDs when the merge is complete.
+     */
+    async mergeFrom(targetIndex) {
+        const targetIndexDimensions = targetIndex.index.getDimension();
+        if (!this._index) {
+            const { IndexFlatIP } = await FaissStore.importFaiss();
+            this._index = new IndexFlatIP(targetIndexDimensions);
+        }
+        const d = this.index.getDimension();
+        if (targetIndexDimensions !== d) {
+            throw new Error("Cannot merge indexes with different dimensions.");
+        }
+        const targetMapping = targetIndex.getMapping();
+        const targetDocstore = targetIndex.getDocstore();
+        const targetSize = targetIndex.index.ntotal();
+        const documentIds = [];
+        const currentDocstoreSize = this.index.ntotal();
+        for (let i = 0; i < targetSize; i += 1) {
+            const targetId = targetMapping[i];
+            documentIds.push(targetId);
+            const targetDocument = targetDocstore.search(targetId);
+            const id = currentDocstoreSize + i;
+            this._mapping[id] = targetId;
+            this.docstore.add({ [targetId]: targetDocument });
+        }
+        this.index.mergeFrom(targetIndex.index);
+        return documentIds;
+    }
+    /**
+     * Loads a FaissStore from a specified directory.
+     * @param directory The directory to load the FaissStore from.
+     * @param embeddings An Embeddings object.
+     * @returns A Promise that resolves with a new FaissStore instance.
+     */
+    static async load(directory, embeddings) {
+        console.warn(`[ZJJDBG2]langchain->load xFaiss`);
+        const fs = await import("node:fs/promises");
+        const path = await import("node:path");
+        const readStore = (directory) => fs
+            .readFile(path.join(directory, "docstore.json"), "utf8")
+            .then(JSON.parse);
+        const readIndex = async (directory) => {
+            const { IndexFlatIP } = await this.importFaiss();
+            return IndexFlatIP.read(path.join(directory, "faiss.index"));
+        };
+        const [[docstoreFiles, mapping], index] = await Promise.all([
+            readStore(directory),
+            readIndex(directory),
+        ]);
+        const docstore = new in_memory_js_1.SynchronousInMemoryDocstore(new Map(docstoreFiles));
+        return new this(embeddings, { docstore, index, mapping });
+    }
+    static async loadFromPython(directory, embeddings) {
+        const fs = await import("node:fs/promises");
+        const path = await import("node:path");
+        const { Parser, NameRegistry } = await this.importPickleparser();
+        class PyDocument extends Map {
+            toDocument() {
+                return new documents_1.Document({
+                    pageContent: this.get("page_content"),
+                    metadata: this.get("metadata"),
+                });
+            }
+        }
+        class PyInMemoryDocstore {
+            constructor() {
+                Object.defineProperty(this, "_dict", {
+                    enumerable: true,
+                    configurable: true,
+                    writable: true,
+                    value: void 0
+                });
+            }
+            toInMemoryDocstore() {
+                const s = new in_memory_js_1.SynchronousInMemoryDocstore();
+                for (const [key, value] of Object.entries(this._dict)) {
+                    s._docs.set(key, value.toDocument());
+                }
+                return s;
+            }
+        }
+        const readStore = async (directory) => {
+            const pkl = await fs.readFile(path.join(directory, "index.pkl"), "binary");
+            const buffer = Buffer.from(pkl, "binary");
+            const registry = new NameRegistry()
+                .register("langchain.docstore.in_memory", "InMemoryDocstore", PyInMemoryDocstore)
+                .register("langchain_community.docstore.in_memory", "InMemoryDocstore", PyInMemoryDocstore)
+                .register("langchain.schema", "Document", PyDocument)
+                .register("langchain.docstore.document", "Document", PyDocument)
+                .register("langchain.schema.document", "Document", PyDocument)
+                .register("langchain_core.documents.base", "Document", PyDocument)
+                .register("pathlib", "WindowsPath", (...args) => args.join("\\"))
+                .register("pathlib", "PosixPath", (...args) => args.join("/"));
+            const pickleparser = new Parser({
+                nameResolver: registry,
+            });
+            const [rawStore, mapping] = pickleparser.parse(buffer);
+            const store = rawStore.toInMemoryDocstore();
+            return { store, mapping };
+        };
+        const readIndex = async (directory) => {
+            const { IndexFlatIP } = await this.importFaiss();
+            return IndexFlatIP.read(path.join(directory, "index.faiss"));
+        };
+        const [store, index] = await Promise.all([
+            readStore(directory),
+            readIndex(directory),
+        ]);
+        return new this(embeddings, {
+            docstore: store.store,
+            index,
+            mapping: store.mapping,
+        });
+    }
+    /**
+     * Creates a new FaissStore from an array of texts, their corresponding
+     * metadata, and an Embeddings object.
+     * @param texts An array of texts.
+     * @param metadatas An array of metadata corresponding to the texts, or a single metadata object to be used for all texts.
+     * @param embeddings An Embeddings object.
+     * @param dbConfig An optional configuration object for the document store.
+     * @returns A Promise that resolves with a new FaissStore instance.
+     */
+    static async fromTexts(texts, metadatas, embeddings, dbConfig) {
+        const docs = [];
+        for (let i = 0; i < texts.length; i += 1) {
+            const metadata = Array.isArray(metadatas) ? metadatas[i] : metadatas;
+            const newDoc = new documents_1.Document({
+                pageContent: texts[i],
+                metadata,
+            });
+            docs.push(newDoc);
+        }
+        return this.fromDocuments(docs, embeddings, dbConfig);
+    }
+    /**
+     * Creates a new FaissStore from an array of Document objects and an
+     * Embeddings object.
+     * @param docs An array of Document objects.
+     * @param embeddings An Embeddings object.
+     * @param dbConfig An optional configuration object for the document store.
+     * @returns A Promise that resolves with a new FaissStore instance.
+     */
+    static async fromDocuments(docs, embeddings, dbConfig) {
+        const args = {
+            docstore: dbConfig?.docstore,
+        };
+        const instance = new this(embeddings, args);
+        await instance.addDocuments(docs);
+        return instance;
+    }
+    /**
+     * Creates a new FaissStore from an existing FaissStore and an Embeddings
+     * object.
+     * @param targetIndex An existing FaissStore.
+     * @param embeddings An Embeddings object.
+     * @param dbConfig An optional configuration object for the document store.
+     * @returns A Promise that resolves with a new FaissStore instance.
+     */
+    static async fromIndex(targetIndex, embeddings, dbConfig) {
+        const args = {
+            docstore: dbConfig?.docstore,
+        };
+        const instance = new this(embeddings, args);
+        await instance.mergeFrom(targetIndex);
+        return instance;
+    }
+    static async importFaiss() {
+        try {
+            // const { default: { IndexFlatL2 }, } = await import("faiss-node");
+            const { IndexFlatL2, Index, IndexFlatIP, MetricType } = require('/mnt/home0/jasper/faiss/xfaiss-node/faiss-node/build/Release/xfaiss-node.node');
+            console.warn(`[ZJJDBG2]langchain->import xfaiss-node.node`);
+            return { IndexFlatIP };
+            // eslint-disable-next-line @typescript-eslint/no-explicit-any
+        }
+        catch (err) {
+            throw new Error(`Could not import faiss-node. Please install faiss-node as a dependency with, e.g. \`npm install -S faiss-node\`.\n\nError: ${err?.message}`);
+        }
+    }
+    static async importPickleparser() {
+        try {
+            const { default: { Parser, NameRegistry }, } = await import("pickleparser");
+            return { Parser, NameRegistry };
+            // eslint-disable-next-line @typescript-eslint/no-explicit-any
+        }
+        catch (err) {
+            throw new Error(`Could not import pickleparser. Please install pickleparser as a dependency with, e.g. \`npm install -S pickleparser\`.\n\nError: ${err?.message}`);
+        }
+    }
+}
+exports.FaissStore = FaissStore;
diff --git a/packages/components/nodes/vectorstores/xFaiss/langchain/xfaiss.d.ts b/packages/components/nodes/vectorstores/xFaiss/langchain/xfaiss.d.ts
new file mode 100644
index 00000000..f3b83371
--- /dev/null
+++ b/packages/components/nodes/vectorstores/xFaiss/langchain/xfaiss.d.ts
@@ -0,0 +1,127 @@
+import type { IndexFlatIP } from "faiss-node";
+import type { NameRegistry, Parser } from "pickleparser";
+import type { EmbeddingsInterface } from "@langchain/core/embeddings";
+import { SaveableVectorStore } from "@langchain/core/vectorstores";
+import { Document } from "@langchain/core/documents";
+import { SynchronousInMemoryDocstore } from "./doc/in_memory.js";
+/**
+ * Interface for the arguments required to initialize a FaissStore
+ * instance.
+ */
+export interface FaissLibArgs {
+    docstore?: SynchronousInMemoryDocstore;
+    index?: IndexFlatIP;
+    mapping?: Record<number, string>;
+}
+/**
+ * A class that wraps the FAISS (Facebook AI Similarity Search) vector
+ * database for efficient similarity search and clustering of dense
+ * vectors.
+ */
+export declare class FaissStore extends SaveableVectorStore {
+    _index?: IndexFlatIP;
+    _mapping: Record<number, string>;
+    docstore: SynchronousInMemoryDocstore;
+    args: FaissLibArgs;
+    _vectorstoreType(): string;
+    getMapping(): Record<number, string>;
+    getDocstore(): SynchronousInMemoryDocstore;
+    constructor(embeddings: EmbeddingsInterface, args: FaissLibArgs);
+    /**
+     * Adds an array of Document objects to the store.
+     * @param documents An array of Document objects.
+     * @returns A Promise that resolves when the documents have been added.
+     */
+    addDocuments(documents: Document[], options?: {
+        ids?: string[];
+    }): Promise<string[]>;
+    get index(): IndexFlatIP;
+    private set index(value);
+    /**
+     * Adds an array of vectors and their corresponding Document objects to
+     * the store.
+     * @param vectors An array of vectors.
+     * @param documents An array of Document objects corresponding to the vectors.
+     * @returns A Promise that resolves with an array of document IDs when the vectors and documents have been added.
+     */
+    addVectors(vectors: number[][], documents: Document[], options?: {
+        ids?: string[];
+    }): Promise<string[]>;
+    /**
+     * Performs a similarity search in the vector store using a query vector
+     * and returns the top k results along with their scores.
+     * @param query A query vector.
+     * @param k The number of top results to return.
+     * @returns A Promise that resolves with an array of tuples, each containing a Document and its corresponding score.
+     */
+    similaritySearchVectorWithScore(query: number[], k: number): Promise<[Document<Record<string, any>>, number][]>;
+    /**
+     * Saves the current state of the FaissStore to a specified directory.
+     * @param directory The directory to save the state to.
+     * @returns A Promise that resolves when the state has been saved.
+     */
+    save(directory: string): Promise<void>;
+    /**
+     * Method to delete documents.
+     * @param params Object containing the IDs of the documents to delete.
+     * @returns A promise that resolves when the deletion is complete.
+     */
+    delete(params: {
+        ids: string[];
+    }): Promise<void>;
+    /**
+     * Merges the current FaissStore with another FaissStore.
+     * @param targetIndex The FaissStore to merge with.
+     * @returns A Promise that resolves with an array of document IDs when the merge is complete.
+     */
+    mergeFrom(targetIndex: FaissStore): Promise<string[]>;
+    /**
+     * Loads a FaissStore from a specified directory.
+     * @param directory The directory to load the FaissStore from.
+     * @param embeddings An Embeddings object.
+     * @returns A Promise that resolves with a new FaissStore instance.
+     */
+    static load(directory: string, embeddings: EmbeddingsInterface): Promise<FaissStore>;
+    static loadFromPython(directory: string, embeddings: EmbeddingsInterface): Promise<FaissStore>;
+    /**
+     * Creates a new FaissStore from an array of texts, their corresponding
+     * metadata, and an Embeddings object.
+     * @param texts An array of texts.
+     * @param metadatas An array of metadata corresponding to the texts, or a single metadata object to be used for all texts.
+     * @param embeddings An Embeddings object.
+     * @param dbConfig An optional configuration object for the document store.
+     * @returns A Promise that resolves with a new FaissStore instance.
+     */
+    static fromTexts(texts: string[], metadatas: object[] | object, embeddings: EmbeddingsInterface, dbConfig?: {
+        docstore?: SynchronousInMemoryDocstore;
+    }): Promise<FaissStore>;
+    /**
+     * Creates a new FaissStore from an array of Document objects and an
+     * Embeddings object.
+     * @param docs An array of Document objects.
+     * @param embeddings An Embeddings object.
+     * @param dbConfig An optional configuration object for the document store.
+     * @returns A Promise that resolves with a new FaissStore instance.
+     */
+    static fromDocuments(docs: Document[], embeddings: EmbeddingsInterface, dbConfig?: {
+        docstore?: SynchronousInMemoryDocstore;
+    }): Promise<FaissStore>;
+    /**
+     * Creates a new FaissStore from an existing FaissStore and an Embeddings
+     * object.
+     * @param targetIndex An existing FaissStore.
+     * @param embeddings An Embeddings object.
+     * @param dbConfig An optional configuration object for the document store.
+     * @returns A Promise that resolves with a new FaissStore instance.
+     */
+    static fromIndex(targetIndex: FaissStore, embeddings: EmbeddingsInterface, dbConfig?: {
+        docstore?: SynchronousInMemoryDocstore;
+    }): Promise<FaissStore>;
+    static importFaiss(): Promise<{
+        IndexFlatIP: typeof IndexFlatIP;
+    }>;
+    static importPickleparser(): Promise<{
+        Parser: typeof Parser;
+        NameRegistry: typeof NameRegistry;
+    }>;
+}
diff --git a/packages/components/nodes/vectorstores/xFaiss/langchain/xfaiss.js b/packages/components/nodes/vectorstores/xFaiss/langchain/xfaiss.js
new file mode 100644
index 00000000..3759f152
--- /dev/null
+++ b/packages/components/nodes/vectorstores/xFaiss/langchain/xfaiss.js
@@ -0,0 +1,370 @@
+import * as uuid from "uuid";
+import { SaveableVectorStore } from "@langchain/core/vectorstores";
+import { Document } from "@langchain/core/documents";
+import { SynchronousInMemoryDocstore } from "./doc/in_memory.js";
+/**
+ * A class that wraps the FAISS (Facebook AI Similarity Search) vector
+ * database for efficient similarity search and clustering of dense
+ * vectors.
+ */
+export class FaissStore extends SaveableVectorStore {
+    _vectorstoreType() {
+        return "faiss";
+    }
+    getMapping() {
+        return this._mapping;
+    }
+    getDocstore() {
+        return this.docstore;
+    }
+    constructor(embeddings, args) {
+        super(embeddings, args);
+        Object.defineProperty(this, "_index", {
+            enumerable: true,
+            configurable: true,
+            writable: true,
+            value: void 0
+        });
+        Object.defineProperty(this, "_mapping", {
+            enumerable: true,
+            configurable: true,
+            writable: true,
+            value: void 0
+        });
+        Object.defineProperty(this, "docstore", {
+            enumerable: true,
+            configurable: true,
+            writable: true,
+            value: void 0
+        });
+        Object.defineProperty(this, "args", {
+            enumerable: true,
+            configurable: true,
+            writable: true,
+            value: void 0
+        });
+        this.args = args;
+        this._index = args.index;
+        this._mapping = args.mapping ?? {};
+        this.embeddings = embeddings;
+        this.docstore = args?.docstore ?? new SynchronousInMemoryDocstore();
+    }
+    /**
+     * Adds an array of Document objects to the store.
+     * @param documents An array of Document objects.
+     * @returns A Promise that resolves when the documents have been added.
+     */
+    async addDocuments(documents, options) {
+        const texts = documents.map(({ pageContent }) => pageContent);
+        return this.addVectors(await this.embeddings.embedDocuments(texts), documents, options);
+    }
+    get index() {
+        if (!this._index) {
+            throw new Error("Vector store not initialised yet. Try calling `fromTexts`, `fromDocuments` or `fromIndex` first.");
+        }
+        return this._index;
+    }
+    set index(index) {
+        this._index = index;
+    }
+    /**
+     * Adds an array of vectors and their corresponding Document objects to
+     * the store.
+     * @param vectors An array of vectors.
+     * @param documents An array of Document objects corresponding to the vectors.
+     * @returns A Promise that resolves with an array of document IDs when the vectors and documents have been added.
+     */
+    async addVectors(vectors, documents, options) {
+        if (vectors.length === 0) {
+            return [];
+        }
+        if (vectors.length !== documents.length) {
+            throw new Error(`Vectors and documents must have the same length`);
+        }
+        const dv = vectors[0].length;
+        if (!this._index) {
+            const { IndexFlatIP } = await FaissStore.importFaiss();
+            this._index = new IndexFlatIP(dv);
+        }
+        const d = this.index.getDimension();
+        if (dv !== d) {
+            throw new Error(`Vectors must have the same length as the number of dimensions (${d})`);
+        }
+        const docstoreSize = this.index.ntotal();
+        const documentIds = options?.ids ?? documents.map(() => uuid.v4());
+        for (let i = 0; i < vectors.length; i += 1) {
+            const documentId = documentIds[i];
+            const id = docstoreSize + i;
+            this.index.add(vectors[i]);
+            this._mapping[id] = documentId;
+            this.docstore.add({ [documentId]: documents[i] });
+        }
+        return documentIds;
+    }
+    /**
+     * Performs a similarity search in the vector store using a query vector
+     * and returns the top k results along with their scores.
+     * @param query A query vector.
+     * @param k The number of top results to return.
+     * @returns A Promise that resolves with an array of tuples, each containing a Document and its corresponding score.
+     */
+    async similaritySearchVectorWithScore(query, k) {
+        const d = this.index.getDimension();
+        if (query.length !== d) {
+            throw new Error(`Query vector must have the same length as the number of dimensions (${d})`);
+        }
+        if (k > this.index.ntotal()) {
+            const total = this.index.ntotal();
+            console.warn(`k (${k}) is greater than the number of elements in the index (${total}), setting k to ${total}`);
+            // eslint-disable-next-line no-param-reassign
+            k = total;
+        }
+        const result = this.index.search(query, k);
+        return result.labels.map((id, index) => {
+            const uuid = this._mapping[id];
+            return [this.docstore.search(uuid), result.distances[index]];
+        });
+    }
+    /**
+     * Saves the current state of the FaissStore to a specified directory.
+     * @param directory The directory to save the state to.
+     * @returns A Promise that resolves when the state has been saved.
+     */
+    async save(directory) {
+        const fs = await import("node:fs/promises");
+        const path = await import("node:path");
+        await fs.mkdir(directory, { recursive: true });
+        await Promise.all([
+            this.index.write(path.join(directory, "faiss.index")),
+            await fs.writeFile(path.join(directory, "docstore.json"), JSON.stringify([
+                Array.from(this.docstore._docs.entries()),
+                this._mapping,
+            ])),
+        ]);
+    }
+    /**
+     * Method to delete documents.
+     * @param params Object containing the IDs of the documents to delete.
+     * @returns A promise that resolves when the deletion is complete.
+     */
+    async delete(params) {
+        const documentIds = params.ids;
+        if (documentIds == null) {
+            throw new Error("No documentIds provided to delete.");
+        }
+        const mappings = new Map(Object.entries(this._mapping).map(([key, value]) => [
+            parseInt(key, 10),
+            value,
+        ]));
+        const reversedMappings = new Map(Array.from(mappings, (entry) => [entry[1], entry[0]]));
+        const missingIds = new Set(documentIds.filter((id) => !reversedMappings.has(id)));
+        if (missingIds.size > 0) {
+            throw new Error(`Some specified documentIds do not exist in the current store. DocumentIds not found: ${Array.from(missingIds).join(", ")}`);
+        }
+        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
+        const indexIdToDelete = documentIds.map((id) => reversedMappings.get(id));
+        // remove from index
+        this.index.removeIds(indexIdToDelete);
+        // remove from docstore
+        documentIds.forEach((id) => {
+            this.docstore._docs.delete(id);
+        });
+        // remove from mappings
+        indexIdToDelete.forEach((id) => {
+            mappings.delete(id);
+        });
+        this._mapping = { ...Array.from(mappings.values()) };
+    }
+    /**
+     * Merges the current FaissStore with another FaissStore.
+     * @param targetIndex The FaissStore to merge with.
+     * @returns A Promise that resolves with an array of document IDs when the merge is complete.
+     */
+    async mergeFrom(targetIndex) {
+        const targetIndexDimensions = targetIndex.index.getDimension();
+        if (!this._index) {
+            const { IndexFlatIP } = await FaissStore.importFaiss();
+            this._index = new IndexFlatIP(targetIndexDimensions);
+        }
+        const d = this.index.getDimension();
+        if (targetIndexDimensions !== d) {
+            throw new Error("Cannot merge indexes with different dimensions.");
+        }
+        const targetMapping = targetIndex.getMapping();
+        const targetDocstore = targetIndex.getDocstore();
+        const targetSize = targetIndex.index.ntotal();
+        const documentIds = [];
+        const currentDocstoreSize = this.index.ntotal();
+        for (let i = 0; i < targetSize; i += 1) {
+            const targetId = targetMapping[i];
+            documentIds.push(targetId);
+            const targetDocument = targetDocstore.search(targetId);
+            const id = currentDocstoreSize + i;
+            this._mapping[id] = targetId;
+            this.docstore.add({ [targetId]: targetDocument });
+        }
+        this.index.mergeFrom(targetIndex.index);
+        return documentIds;
+    }
+    /**
+     * Loads a FaissStore from a specified directory.
+     * @param directory The directory to load the FaissStore from.
+     * @param embeddings An Embeddings object.
+     * @returns A Promise that resolves with a new FaissStore instance.
+     */
+    static async load(directory, embeddings) {
+        const fs = await import("node:fs/promises");
+        const path = await import("node:path");
+        const readStore = (directory) => fs
+            .readFile(path.join(directory, "docstore.json"), "utf8")
+            .then(JSON.parse);
+        const readIndex = async (directory) => {
+            const { IndexFlatIP } = await this.importFaiss();
+            return IndexFlatIP.read(path.join(directory, "faiss.index"));
+        };
+        const [[docstoreFiles, mapping], index] = await Promise.all([
+            readStore(directory),
+            readIndex(directory),
+        ]);
+        const docstore = new SynchronousInMemoryDocstore(new Map(docstoreFiles));
+        return new this(embeddings, { docstore, index, mapping });
+    }
+    static async loadFromPython(directory, embeddings) {
+        const fs = await import("node:fs/promises");
+        const path = await import("node:path");
+        const { Parser, NameRegistry } = await this.importPickleparser();
+        class PyDocument extends Map {
+            toDocument() {
+                return new Document({
+                    pageContent: this.get("page_content"),
+                    metadata: this.get("metadata"),
+                });
+            }
+        }
+        class PyInMemoryDocstore {
+            constructor() {
+                Object.defineProperty(this, "_dict", {
+                    enumerable: true,
+                    configurable: true,
+                    writable: true,
+                    value: void 0
+                });
+            }
+            toInMemoryDocstore() {
+                const s = new SynchronousInMemoryDocstore();
+                for (const [key, value] of Object.entries(this._dict)) {
+                    s._docs.set(key, value.toDocument());
+                }
+                return s;
+            }
+        }
+        const readStore = async (directory) => {
+            const pkl = await fs.readFile(path.join(directory, "index.pkl"), "binary");
+            const buffer = Buffer.from(pkl, "binary");
+            const registry = new NameRegistry()
+                .register("langchain.docstore.in_memory", "InMemoryDocstore", PyInMemoryDocstore)
+                .register("langchain_community.docstore.in_memory", "InMemoryDocstore", PyInMemoryDocstore)
+                .register("langchain.schema", "Document", PyDocument)
+                .register("langchain.docstore.document", "Document", PyDocument)
+                .register("langchain.schema.document", "Document", PyDocument)
+                .register("langchain_core.documents.base", "Document", PyDocument)
+                .register("pathlib", "WindowsPath", (...args) => args.join("\\"))
+                .register("pathlib", "PosixPath", (...args) => args.join("/"));
+            const pickleparser = new Parser({
+                nameResolver: registry,
+            });
+            const [rawStore, mapping] = pickleparser.parse(buffer);
+            const store = rawStore.toInMemoryDocstore();
+            return { store, mapping };
+        };
+        const readIndex = async (directory) => {
+            const { IndexFlatIP } = await this.importFaiss();
+            return IndexFlatIP.read(path.join(directory, "index.faiss"));
+        };
+        const [store, index] = await Promise.all([
+            readStore(directory),
+            readIndex(directory),
+        ]);
+        return new this(embeddings, {
+            docstore: store.store,
+            index,
+            mapping: store.mapping,
+        });
+    }
+    /**
+     * Creates a new FaissStore from an array of texts, their corresponding
+     * metadata, and an Embeddings object.
+     * @param texts An array of texts.
+     * @param metadatas An array of metadata corresponding to the texts, or a single metadata object to be used for all texts.
+     * @param embeddings An Embeddings object.
+     * @param dbConfig An optional configuration object for the document store.
+     * @returns A Promise that resolves with a new FaissStore instance.
+     */
+    static async fromTexts(texts, metadatas, embeddings, dbConfig) {
+        const docs = [];
+        for (let i = 0; i < texts.length; i += 1) {
+            const metadata = Array.isArray(metadatas) ? metadatas[i] : metadatas;
+            const newDoc = new Document({
+                pageContent: texts[i],
+                metadata,
+            });
+            docs.push(newDoc);
+        }
+        return this.fromDocuments(docs, embeddings, dbConfig);
+    }
+    /**
+     * Creates a new FaissStore from an array of Document objects and an
+     * Embeddings object.
+     * @param docs An array of Document objects.
+     * @param embeddings An Embeddings object.
+     * @param dbConfig An optional configuration object for the document store.
+     * @returns A Promise that resolves with a new FaissStore instance.
+     */
+    static async fromDocuments(docs, embeddings, dbConfig) {
+        const args = {
+            docstore: dbConfig?.docstore,
+        };
+        const instance = new this(embeddings, args);
+        await instance.addDocuments(docs);
+        return instance;
+    }
+    /**
+     * Creates a new FaissStore from an existing FaissStore and an Embeddings
+     * object.
+     * @param targetIndex An existing FaissStore.
+     * @param embeddings An Embeddings object.
+     * @param dbConfig An optional configuration object for the document store.
+     * @returns A Promise that resolves with a new FaissStore instance.
+     */
+    static async fromIndex(targetIndex, embeddings, dbConfig) {
+        const args = {
+            docstore: dbConfig?.docstore,
+        };
+        const instance = new this(embeddings, args);
+        await instance.mergeFrom(targetIndex);
+        return instance;
+    }
+    static async importFaiss() {
+        try {
+            // const { default: { IndexFlatL2 }, } = await import("faiss-node.node");
+            const { IndexFlatL2, Index, IndexFlatIP, MetricType } = require('./node/xfaiss-node.node');
+            console.warn(`[ZJJDBG2]import xfaiss-node.node`);
+
+            return { IndexFlatIP };
+            // eslint-disable-next-line @typescript-eslint/no-explicit-any
+        }
+        catch (err) {
+            throw new Error(`Could not import faiss-node. Please install faiss-node as a dependency with, e.g. \`npm install -S faiss-node\`.\n\nError: ${err?.message}`);
+        }
+    }
+    static async importPickleparser() {
+        try {
+            const { default: { Parser, NameRegistry }, } = await import("pickleparser");
+            return { Parser, NameRegistry };
+            // eslint-disable-next-line @typescript-eslint/no-explicit-any
+        }
+        catch (err) {
+            throw new Error(`Could not import pickleparser. Please install pickleparser as a dependency with, e.g. \`npm install -S pickleparser\`.\n\nError: ${err?.message}`);
+        }
+    }
+}
diff --git a/packages/components/package.json b/packages/components/package.json
index 9741dc73..01eaa667 100644
--- a/packages/components/package.json
+++ b/packages/components/package.json
@@ -6,6 +6,7 @@
     "types": "dist/src/index.d.ts",
     "scripts": {
         "build": "tsc && gulp",
+        "postbuild": "cp -rf ./nodes/vectorstores/xFaiss/langchain/node ./dist/nodes/vectorstores/xFaiss/langchain/",
         "dev:gulp": "gulp",
         "dev": "tsc-watch --noClear -p ./tsconfig.json --onSuccess \"pnpm dev:gulp\"",
         "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
diff --git a/packages/components/tsconfig.json b/packages/components/tsconfig.json
index bda815f9..463e3b85 100644
--- a/packages/components/tsconfig.json
+++ b/packages/components/tsconfig.json
@@ -14,7 +14,8 @@
         "strictPropertyInitialization": false,
         "useUnknownInCatchVariables": false,
         "declaration": true,
-        "module": "commonjs"
+        "module": "commonjs",
+        "allowJs": true
     },
     "include": ["src", "nodes", "credentials"],
     "exclude": ["gulpfile.ts", "node_modules", "dist"]
